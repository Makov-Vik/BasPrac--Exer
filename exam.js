// классы, коллекции, прототипы, модули, контекст, частичное применение, каррирование, программные абстракции
// антипатерны ооп, парадигмы программирование, статические методы,  set/get

// ЗАМЫКАНИЕ ======================================================================================
/* Функция в функции, где из внутренней вызываются внешние переменные
Если вернуть функцию g из функции f, то g будет видеть контекст 
функции f, так же, как и свои аргументы. Если f возвращает g, то говорят, 
что экземпляр g замкнул контекст f.
*/

// const outer = (num) => {
//   return inner = (num2) => {
//     console.log(num * num2);
//   }
// }
// const firstNum = outer(5);
// firstNum(2);

/*  Стрелочная функция не имеет собственного контекста this. 
    Она их берёт от родительских
*/


// ПАРАДИГМЫ ======================================================================================
// https://gb.ru/posts/programming_types
/*
1 Императивное:
1.1 ООП(Объектно-Ориентированное Прог.) - команды вызываються последовательно, изменяя данные
    Работает с Объектами
1.2 ПРОЦЕДУРНОЕ -  процедуры - команды, которые применяются в определённом порядке
    и последовательно меняют состояние памяти.
    После применения всех команд программа выдаёт результат.
2 Декларативное:
2.1 ФУНКЦИОНАЛЬНОЕ - основано на функциях, каждая выполняет определённую задачу
3.1 ДЖЕНЕРИКИ / Generics - обобщенное программирование - 
    парадигма, позволяющая обобщенно описать алгоритмы и структуры данных, 
    абстрагируясь от конкретных типов
*/

// МЕТОД / Method – ===============================================================================
// -функция являющаяся свойством(ключем) в объекте 

// Суперпозиция / Superposition ===================================================================
/* Объединение вызова функций в выражения таким образом, 
что результат одних функций становится аргументами других функций.
*/

// Каррирование / Curry ===========================================================================
/*
 это трансформация функций таким образом, чтобы они принимали 
 аргументы не как f(a, b, c), а как f(a)(b)(c).
*/ 

// const curry = fn => (...args) => {
//   if (fn.length > args.length) {
//     const f = fn.bind(null, ...args);
//     return curry(f);
//   } else {
//     return fn(...args);
//   }
// };

// // Usage

// const sum4 = (a, b, c, d) => (a + b + c + d);

// const f = curry(sum4);
// const y1 = sum4(1, 2, 3, 4);
// const y2 = f(1, 2, 3, 4);
// const y3 = f(1, 2, 3)(4);
// const y4 = f(1, 2)(3)(4);
// const y5 = f(1)(2)(3)(4);

// Обертка / Wrapper ==============================================================================
/* функция, которая оборачивает другую функцию (иногда объект, 
  интерфейс или функциональный объект), добавляя ему дополнительное поведение
*/

// МЕМОИЗАЦИЯ / Memoization =======================================================================
// - обертка, сохраняющая результаты выполнения функции для предотвращения повторных вычислений

// ЧЕИНИНГ/ Chaining ==============================================================================
// цепочный синтаксис вызова функций 
// total(april)(may)(july) или методов array.filter(f1).reduce(f2)

// КЛАССЫ / Class =================================================================================
// https://learn.javascript.ru/class

// Синглтон / Singleton ===========================================================================
// шаблон проектирования, предполагающий, что в одном пространстве имен 
// (процессе, приложении, базе данных) будет только один экземпляр класса 
// (или просто один подобный объект) к которому можно обратиться по определенному имени;


